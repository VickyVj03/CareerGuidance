{"ast":null,"code":"import { elementIndex } from '../../shared/utils.js';\nexport default function loopFix() {\n  let {\n    slideRealIndex,\n    slideTo = true,\n    direction,\n    setTranslate,\n    activeSlideIndex,\n    byController\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const swiper = this;\n  if (!swiper.params.loop) return;\n  swiper.emit('beforeLoopFix');\n  const {\n    slides,\n    allowSlidePrev,\n    allowSlideNext,\n    slidesEl,\n    params\n  } = swiper;\n  swiper.allowSlidePrev = true;\n  swiper.allowSlideNext = true;\n  if (swiper.virtual && params.virtual.enabled) {\n    if (slideTo) {\n      if (!params.centeredSlides && swiper.snapIndex === 0) {\n        swiper.slideTo(swiper.virtual.slides.length, 0, false, true);\n      } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {\n        swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);\n      } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {\n        swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);\n      }\n    }\n    swiper.allowSlidePrev = allowSlidePrev;\n    swiper.allowSlideNext = allowSlideNext;\n    swiper.emit('loopFix');\n    return;\n  }\n  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10));\n  let loopedSlides = params.loopedSlides || slidesPerView;\n  if (loopedSlides % params.slidesPerGroup !== 0) {\n    loopedSlides += params.slidesPerGroup - loopedSlides % params.slidesPerGroup;\n  }\n  swiper.loopedSlides = loopedSlides;\n  const prependSlidesIndexes = [];\n  const appendSlidesIndexes = [];\n  let activeIndex = swiper.activeIndex;\n  if (typeof activeSlideIndex === 'undefined') {\n    activeSlideIndex = elementIndex(swiper.slides.filter(el => el.classList.contains('swiper-slide-active'))[0]);\n  } else {\n    activeIndex = activeSlideIndex;\n  }\n  const isNext = direction === 'next' || !direction;\n  const isPrev = direction === 'prev' || !direction;\n  let slidesPrepended = 0;\n  let slidesAppended = 0;\n  // prepend last slides before start\n  if (activeSlideIndex < loopedSlides) {\n    slidesPrepended = loopedSlides - activeSlideIndex;\n    for (let i = 0; i < loopedSlides - activeSlideIndex; i += 1) {\n      const index = i - Math.floor(i / slides.length) * slides.length;\n      prependSlidesIndexes.push(slides.length - index - 1);\n    }\n  } else if (activeSlideIndex /* + slidesPerView */ > swiper.slides.length - loopedSlides * 2) {\n    slidesAppended = activeSlideIndex - (swiper.slides.length - loopedSlides * 2);\n    for (let i = 0; i < slidesAppended; i += 1) {\n      const index = i - Math.floor(i / slides.length) * slides.length;\n      appendSlidesIndexes.push(index);\n    }\n  }\n  if (isPrev) {\n    prependSlidesIndexes.forEach(index => {\n      slidesEl.prepend(swiper.slides[index]);\n    });\n  }\n  if (isNext) {\n    appendSlidesIndexes.forEach(index => {\n      slidesEl.append(swiper.slides[index]);\n    });\n  }\n  swiper.recalcSlides();\n  if (params.watchSlidesProgress) {\n    swiper.updateSlidesOffset();\n  }\n  if (slideTo) {\n    if (prependSlidesIndexes.length > 0 && isPrev) {\n      if (typeof slideRealIndex === 'undefined') {\n        const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n        const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];\n        const diff = newSlideTranslate - currentSlideTranslate;\n        swiper.slideTo(activeIndex + slidesPrepended, 0, false, true);\n        if (setTranslate) {\n          swiper.touches[swiper.isHorizontal() ? 'startX' : 'startY'] += diff;\n        }\n      } else {\n        if (setTranslate) {\n          swiper.slideToLoop(slideRealIndex, 0, false, true);\n        }\n      }\n    } else if (appendSlidesIndexes.length > 0 && isNext) {\n      if (typeof slideRealIndex === 'undefined') {\n        const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n        const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];\n        const diff = newSlideTranslate - currentSlideTranslate;\n        swiper.slideTo(activeIndex - slidesAppended, 0, false, true);\n        if (setTranslate) {\n          swiper.touches[swiper.isHorizontal() ? 'startX' : 'startY'] += diff;\n        }\n      } else {\n        swiper.slideToLoop(slideRealIndex, 0, false, true);\n      }\n    }\n  }\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n  if (swiper.controller && swiper.controller.control && !byController) {\n    const loopParams = {\n      slideRealIndex,\n      slideTo: false,\n      direction,\n      setTranslate,\n      activeSlideIndex,\n      byController: true\n    };\n    if (Array.isArray(swiper.controller.control)) {\n      swiper.controller.control.forEach(c => {\n        if (c.params.loop) c.loopFix(loopParams);\n      });\n    } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {\n      swiper.controller.control.loopFix(loopParams);\n    }\n  }\n  swiper.emit('loopFix');\n}","map":{"version":3,"names":["elementIndex","loopFix","slideRealIndex","slideTo","direction","setTranslate","activeSlideIndex","byController","swiper","params","loop","emit","slides","allowSlidePrev","allowSlideNext","slidesEl","virtual","enabled","centeredSlides","snapIndex","length","slidesPerView","snapGrid","slidesBefore","slidesPerViewDynamic","Math","ceil","parseFloat","loopedSlides","slidesPerGroup","prependSlidesIndexes","appendSlidesIndexes","activeIndex","filter","el","classList","contains","isNext","isPrev","slidesPrepended","slidesAppended","i","index","floor","push","forEach","prepend","append","recalcSlides","watchSlidesProgress","updateSlidesOffset","currentSlideTranslate","slidesGrid","newSlideTranslate","diff","touches","isHorizontal","slideToLoop","controller","control","loopParams","Array","isArray","c","constructor"],"sources":["C:/Users/ADMIN/Documents/CGT Website/CGT-main/CGT-main/node_modules/swiper/core/loop/loopFix.js"],"sourcesContent":["import { elementIndex } from '../../shared/utils.js';\nexport default function loopFix({\n  slideRealIndex,\n  slideTo = true,\n  direction,\n  setTranslate,\n  activeSlideIndex,\n  byController\n} = {}) {\n  const swiper = this;\n  if (!swiper.params.loop) return;\n  swiper.emit('beforeLoopFix');\n  const {\n    slides,\n    allowSlidePrev,\n    allowSlideNext,\n    slidesEl,\n    params\n  } = swiper;\n  swiper.allowSlidePrev = true;\n  swiper.allowSlideNext = true;\n  if (swiper.virtual && params.virtual.enabled) {\n    if (slideTo) {\n      if (!params.centeredSlides && swiper.snapIndex === 0) {\n        swiper.slideTo(swiper.virtual.slides.length, 0, false, true);\n      } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {\n        swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);\n      } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {\n        swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);\n      }\n    }\n    swiper.allowSlidePrev = allowSlidePrev;\n    swiper.allowSlideNext = allowSlideNext;\n    swiper.emit('loopFix');\n    return;\n  }\n  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10));\n  let loopedSlides = params.loopedSlides || slidesPerView;\n  if (loopedSlides % params.slidesPerGroup !== 0) {\n    loopedSlides += params.slidesPerGroup - loopedSlides % params.slidesPerGroup;\n  }\n  swiper.loopedSlides = loopedSlides;\n  const prependSlidesIndexes = [];\n  const appendSlidesIndexes = [];\n  let activeIndex = swiper.activeIndex;\n  if (typeof activeSlideIndex === 'undefined') {\n    activeSlideIndex = elementIndex(swiper.slides.filter(el => el.classList.contains('swiper-slide-active'))[0]);\n  } else {\n    activeIndex = activeSlideIndex;\n  }\n  const isNext = direction === 'next' || !direction;\n  const isPrev = direction === 'prev' || !direction;\n  let slidesPrepended = 0;\n  let slidesAppended = 0;\n  // prepend last slides before start\n  if (activeSlideIndex < loopedSlides) {\n    slidesPrepended = loopedSlides - activeSlideIndex;\n    for (let i = 0; i < loopedSlides - activeSlideIndex; i += 1) {\n      const index = i - Math.floor(i / slides.length) * slides.length;\n      prependSlidesIndexes.push(slides.length - index - 1);\n    }\n  } else if (activeSlideIndex /* + slidesPerView */ > swiper.slides.length - loopedSlides * 2) {\n    slidesAppended = activeSlideIndex - (swiper.slides.length - loopedSlides * 2);\n    for (let i = 0; i < slidesAppended; i += 1) {\n      const index = i - Math.floor(i / slides.length) * slides.length;\n      appendSlidesIndexes.push(index);\n    }\n  }\n  if (isPrev) {\n    prependSlidesIndexes.forEach(index => {\n      slidesEl.prepend(swiper.slides[index]);\n    });\n  }\n  if (isNext) {\n    appendSlidesIndexes.forEach(index => {\n      slidesEl.append(swiper.slides[index]);\n    });\n  }\n  swiper.recalcSlides();\n  if (params.watchSlidesProgress) {\n    swiper.updateSlidesOffset();\n  }\n  if (slideTo) {\n    if (prependSlidesIndexes.length > 0 && isPrev) {\n      if (typeof slideRealIndex === 'undefined') {\n        const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n        const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];\n        const diff = newSlideTranslate - currentSlideTranslate;\n        swiper.slideTo(activeIndex + slidesPrepended, 0, false, true);\n        if (setTranslate) {\n          swiper.touches[swiper.isHorizontal() ? 'startX' : 'startY'] += diff;\n        }\n      } else {\n        if (setTranslate) {\n          swiper.slideToLoop(slideRealIndex, 0, false, true);\n        }\n      }\n    } else if (appendSlidesIndexes.length > 0 && isNext) {\n      if (typeof slideRealIndex === 'undefined') {\n        const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n        const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];\n        const diff = newSlideTranslate - currentSlideTranslate;\n        swiper.slideTo(activeIndex - slidesAppended, 0, false, true);\n        if (setTranslate) {\n          swiper.touches[swiper.isHorizontal() ? 'startX' : 'startY'] += diff;\n        }\n      } else {\n        swiper.slideToLoop(slideRealIndex, 0, false, true);\n      }\n    }\n  }\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n  if (swiper.controller && swiper.controller.control && !byController) {\n    const loopParams = {\n      slideRealIndex,\n      slideTo: false,\n      direction,\n      setTranslate,\n      activeSlideIndex,\n      byController: true\n    };\n    if (Array.isArray(swiper.controller.control)) {\n      swiper.controller.control.forEach(c => {\n        if (c.params.loop) c.loopFix(loopParams);\n      });\n    } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {\n      swiper.controller.control.loopFix(loopParams);\n    }\n  }\n  swiper.emit('loopFix');\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}